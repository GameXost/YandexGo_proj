/*
 * Driver Service API
 *
 * API for managing drivers and ride operations
 *
 * API version: 2.0
 * Contact: sergejs.dyldin@yandex.ru
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package server

import (
	"context"
	"net/http"

	pb "github.com/GameXost/YandexGo_proj/DRIVERS/API/generated/drivers"
	"github.com/gin-gonic/gin"
)

type RidesCustomHandler struct {
	*RidesAPI
	Client pb.RidesClient
}

func NewRidesCustomHandler(cli pb.RidesClient) *RidesCustomHandler {
	return &RidesCustomHandler{
		RidesAPI: &RidesAPI{},
		Client:   cli,
	}
}

// Post /ride/:id/accept
// Accept a ride
func (h *RidesCustomHandler) AcceptRide(c *gin.Context) {
	rideID := c.Param("id")

	// Pass the token if available
	ctx := context.WithValue(c.Request.Context(), pb.ContextAccessToken, c.GetHeader("Authorization"))

	// Use the gRPC client to make the API call
	resp, httpResp, err := h.Client.AcceptRide(ctx, rideID).Execute()

	// Handle errors
	if err != nil {
		// If we got an HTTP response, use its status code
		statusCode := http.StatusInternalServerError
		if httpResp != nil {
			statusCode = httpResp.StatusCode
		}

		c.JSON(statusCode, gin.H{"error": err.Error()})
		return
	}

	c.JSON(httpResp.StatusCode, resp)
}

// Post /ride/:id/cancel
// Cancel a ride
func (h *RidesCustomHandler) CancelRide(c *gin.Context) {
	rideID := c.Param("id")

	// Pass the token if available
	ctx := context.WithValue(c.Request.Context(), pb.ContextAccessToken, c.GetHeader("Authorization"))

	// Use the gRPC client to make the API call
	resp, httpResp, err := h.Client.CancelRide(ctx, rideID).Execute()

	// Handle errors
	if err != nil {
		// If we got an HTTP response, use its status code
		statusCode := http.StatusInternalServerError
		if httpResp != nil {
			statusCode = httpResp.StatusCode
		}

		c.JSON(statusCode, gin.H{"error": err.Error()})
		return
	}

	c.JSON(httpResp.StatusCode, resp)
}

// Post /ride/:id/complete
// Complete a ride
func (h *RidesCustomHandler) CompleteRide(c *gin.Context) {
	rideID := c.Param("id")

	// Pass the token if available
	ctx := context.WithValue(c.Request.Context(), pb.ContextAccessToken, c.GetHeader("Authorization"))

	// Use the gRPC client to make the API call
	resp, httpResp, err := h.Client.CompleteRide(ctx, rideID).Execute()

	// Handle errors
	if err != nil {
		// If we got an HTTP response, use its status code
		statusCode := http.StatusInternalServerError
		if httpResp != nil {
			statusCode = httpResp.StatusCode
		}

		c.JSON(statusCode, gin.H{"error": err.Error()})
		return
	}

	c.JSON(httpResp.StatusCode, resp)
}

// Get /driver/current_ride/:id
// Get current ride information
func (h *RidesCustomHandler) GetCurrentRide(c *gin.Context) {
	driverID := c.Param("id")

	// Pass the token if available
	ctx := context.WithValue(c.Request.Context(), pb.ContextAccessToken, c.GetHeader("Authorization"))

	// Use the gRPC client to make the API call
	resp, httpResp, err := h.Client.GetCurrentRide(ctx, driverID).Execute()

	// Handle errors
	if err != nil {
		// If we got an HTTP response, use its status code
		statusCode := http.StatusInternalServerError
		if httpResp != nil {
			statusCode = httpResp.StatusCode
		}

		c.JSON(statusCode, gin.H{"error": err.Error()})
		return
	}

	c.JSON(httpResp.StatusCode, resp)
}

// Get /driver/:id/rides
// Get driver's ride history
func (h *RidesCustomHandler) GetRideHistory(c *gin.Context) {
	driverID := c.Param("id")

	// Pass the token if available
	ctx := context.WithValue(c.Request.Context(), pb.ContextAccessToken, c.GetHeader("Authorization"))

	// Use the gRPC client to make the API call
	resp, httpResp, err := h.Client.GetRideHistory(ctx, driverID).Execute()

	// Handle errors
	if err != nil {
		// If we got an HTTP response, use its status code
		statusCode := http.StatusInternalServerError
		if httpResp != nil {
			statusCode = httpResp.StatusCode
		}

		c.JSON(statusCode, gin.H{"error": err.Error()})
		return
	}

	c.JSON(httpResp.StatusCode, resp)
}
