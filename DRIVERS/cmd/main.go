/*
 * Driver Service API
 *
 * API for managing drivers and ride operations
 *
 * API version: 2.0
 * Contact: sergejs.dyldin@yandex.ru
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package main

import (
	"context"
	"crypto/rsa"
	//"errors"
	//"fmt"
	//"github.com/GameXost/YandexGo_proj/DRIVERS/internal/models"
	//"github.com/gin-gonic/gin"
	"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	//"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/redis/go-redis/v9"
	"github.com/segmentio/kafka-go"
	"google.golang.org/grpc"

	//"google.golang.org/grpc/codes"
	"google.golang.org/grpc/credentials/insecure"
	//"google.golang.org/grpc/status"
	"net"

	"log"
	"net/http"

	pb "github.com/GameXost/YandexGo_proj/DRIVERS/API/generated/drivers"
	"github.com/GameXost/YandexGo_proj/DRIVERS/internal/repository"
	server "github.com/GameXost/YandexGo_proj/DRIVERS/internal/server"
	"github.com/GameXost/YandexGo_proj/DRIVERS/internal/services"
	//"github.com/GameXost/YandexGo_proj/DRIVERS/server/go"
	//sw "github.com/GameXost/YandexGo_proj/DRIVERS/server/go"
)

var publicKey *rsa.PublicKey // заебать мишу, ключики ыадаыива

func main() {
	ctx := context.Background()

	// DB connection
	connStr := "postgres://admin:secret@95.163.222.30:5432/Auth?sslmode=disable"
	dbpool, err := pgxpool.New(ctx, connStr)
	if err != nil {
		log.Fatalf("Unable to create pool: %v", err)
	}
	defer dbpool.Close()
	log.Println("PGX working")

	// REDIS connection
	redisClient := redis.NewClient(&redis.Options{
		Addr:     "95.163.222.30:6379",
		Password: "secret",
		DB:       0,
	})

	//redisCtx, cancel := context.WithTimeout(ctx, 5*time.Second)
	//defer cancel()
	//if err := redisClient.Ping(redisCtx).Err(); err != nil {
	//	log.Fatalf("Unable to connect to redis: %v", err)
	//}

	//testCtx, testCancel := context.WithTimeout(ctx, 3*time.Second)
	//defer testCancel()
	//if _, err := redisClient.Set(testCtx, "healthcheck", "ok", 300*time.Second).Result(); err != nil {
	//	log.Fatalf("Redis test operation failed: %v", err)
	//}
	//log.Println("REDIS working")

	// Kafka connection
	kafkaWriter := kafka.NewWriter(kafka.WriterConfig{
		Brokers: []string{"localhost:9092"},
		Topic:   "rides",
	})
	defer kafkaWriter.Close()
	log.Println("Kafka working")

	repo := repository.NewDriverRepository(dbpool)
	driverService := services.NewDriverService(repo, redisClient, kafkaWriter)

	// server up
	sv := &server.DriverServer{
		Service: driverService,
	}

	// gRPC server up
	grpcServer := grpc.NewServer(
		grpc.UnaryInterceptor(server.AuthInterceptor(publicKey)),
	)
	pb.RegisterDriversServer(grpcServer, sv)
	grpcListener, err := net.Listen("tcp", ":9093")
	if err != nil {
		log.Fatalf("Unable to listen on 9093: %v", err)
	}
	go func() {
		log.Println("GRPC server listening on :9093")
		if err := grpcServer.Serve(grpcListener); err != nil {
			log.Fatalf("Unable to start grpc server: %v", err)
		}
	}()

	//gRPC gateway up
	mux := runtime.NewServeMux()
	opts := []grpc.DialOption{grpc.WithTransportCredentials(insecure.NewCredentials())}
	err = pb.RegisterDriversHandlerFromEndpoint(ctx, mux, "localhost:9093", opts)
	if err != nil {
		log.Fatalf("Unable to register handler: %v", err)
	}
	log.Println("Mux gateway Listening on localhost:9092")
	if err := http.ListenAndServe(":9092", mux); err != nil {
		log.Fatalf("Unable to listen on 9092: %v", err)
	}

	//conn, err := grpc.DialContext(ctx, "localhost:50051", grpc.WithTransportCredentials(insecure.NewCredentials()))
	//if err != nil {
	//	log.Fatalf("Unable to connect to grpc server: %v", err)
	//}
	//grpcClient := pb.NewDriversClient(conn)

	//driverHandler := sw.NewDriverCustomHandler(grpcClient)
	//locationHandler := sw.NewLocationCustomHandler(grpcClient)
	//passangersHandler := sw.NewPassangerCustomHandler(grpcClient)
	//ridesHandler := sw.NewRidesCustomHandler(grpcClient)
	//handlers := sw.ApiHandleFunctions{}
	//router := sw.NewRouter(handlers)

	//router.Any("/any", gin.WrapH(mux))
	//if err := router.Run("9092"); err != nil {
	//	log.Fatalf("Unable to listen on 9092: %v", err)
	//}

	//log.Fatal(http.ListenAndServe(":8080", router))

}

func initKafkaProducer() *kafka.Writer {
	return &kafka.Writer{
		Addr:     kafka.TCP("localhost:9092"),
		Topic:    "rides",
		Balancer: &kafka.LeastBytes{},
	}
}

func initKafkaConsumer() {
	r := kafka.NewReader(kafka.ReaderConfig{
		Brokers:  []string{"localhost:9092"},
		Topic:    "rides",
		GroupID:  "taxi_app_group",
		MinBytes: 10e3,
		MaxBytes: 10e6,
	})
	for {
		msg, err := r.ReadMessage(context.Background())
		if err != nil {
			log.Printf("Error reading message: %v", err)
			continue
		}
		log.Printf("Message on %s: %s = %s\n", msg.Topic, msg.Key, msg.Value)
	}
}
